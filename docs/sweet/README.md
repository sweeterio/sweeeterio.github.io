# Sweet

## Sweet 介绍

Sweet 是 Sweetest 的升级版，实现了如下优化：

1. 优化、统一和简化书写格式，用例编写将更加简洁
2. 支持通过 api 接口启动
3. 支持自定义关键字模块，提供统一的开发规范及示例
4. 支持多端测试，可同时启动多个浏览器、App
5. 支持多份测试套件并行执行
6. 更新 logo
7. 删减 Excel格式、JUnit格式的测试报告
8. 优化了Web版测试报告

Sweet 的愿景是构建一个寂静生长的测试生态，优势如下：

1. 提炼了核心功能：减少框架开发工作量，让核心功能高度稳定
2. 关键字实现模块化：关键字和核心功能高度解耦，关键字模块可按需安装和加载
3. 关键字模块实现标准化：第三方开发可以很简单的开发和发布自己的关键字模块
4. 提供接口调用：支持第三方开发 web 管理系统
5. 格式优化：测试用例、元素列表、测试数据合并在一张表格，方便编写和分享
6. 并发执行：提高了执行效率
7. 多端执行：满足不同场景需求

- 测试用例示例

    ![testcase](../_snapshot/sweetcase.png)

- 元素列表示例

    ![testcase](../_snapshot/sweetelement.png)


## 一、使用说明

### 1. 安装及配置

#### 系统要求

1. Windows 10/Windows Server 2016
2. Python 3.9 (*必须)


#### 安装 sweet

安装 sweet

```
pip install sweet
```

#### 按需安装官方`关键字模块`

```
pip install sweet.web
pip install sweet.http
pip install sweet.mobile
pip install sweet.db
pip install sweet.file
```
> 备注：示例的测试用例有用到，请全部安装，后续可自行卸载

#### 更新 sweet (如果需要的话)

```
pip install -U sweet
```

更新官方`关键字模块`

```
pip install -U sweet.web
......
```

### 2. 下载示例项目

#### 正式版

请下载 https://github.com/sweeterio/sweet_example

下载完成后，请参考 sweet_example 中的 README.md 操作

#### 体验版

请下载 https://github.com/sweeterio/test_example

下载完成后，请参考 test_example 中的 README.md 操作

### 3. 启动 Web「测试报告」服务

#### 启动 Web「测试报告」服务

在项目目录（sweet_example），用命令行执行如下命令：

```
python app.py
```

打开网页：http://127.0.0.1:80 查看测试报告


### 4. 执行自动化测试示例

在项目目录下（sweet_example），用命令行执行如下命令：

```
python start.py
```

![sweet run log](../_snapshot/runlog.png) 

## 二、与 Sweetest 不同之处

### 1. 用例组织结构

Sweet 改进了用例组织结构

```shell
sweet_example            # Sweet 自动化测试工作目录
├─log                    # 执行日志目录
│  ├─xxx测试计划         # 测试计划日志目录
│  └─...
├─report                 # 测试报告目录
│  └─xxx测试计划
├─xxx测试计划            # 测试计划目录，由用户编写，1个或多个测试套件组成一个测试计划
│  ├─baidu.xlsx          # 测试套件：baidu，其中包含了用例、元素列表（包含启动配置）、测试数据
│  └─echo.xlsx           # 测试套件：echo
├─app.py                 # 测试报告 Web 服务启动脚本
└─start.py               # 用例执行启动脚本
```

### 2. 用例格式

在 Sweet 中，用例、元素列表和测试数据写在一个 Excel 表格中，这个表格是一个完整的测试套件，请参见示例 echo.xlsx

1. elements 如下：

| app  | element | value                                 | by | frame |
|------|---------|---------------------------------------|----|-------|
| echo | module  | http                                  |    |       |
|      | setting | {'path': 'https://postman-echo.com/'} |json|       |
|      | get请求 | /get                                  |    |       |
|      | get请求#| /get?foo1=#&foo2=#                    |    |       |

- 在 Sweet 中，我们支持同时测试多个接口或开启多个浏览器，这些对象我们统称为 app，在此表中 app 列就是对应的（自定义）名称，比如测试 postman-echo.com 接口，可以起名 echo。
- 每个 app 都要有1个 module 属性，其值应该为关键字模块名，如：http，web，db等定义在sweet\modules 目录下的模块。
- 每个 app 可以有0个或1个 setting 属性，定义该模块的全局属性或启动属性，可以参见 baidu.xlsx。该属性值的格式必须为字典，且其 by 值为 json。

2. 测试用例如下：

| id  | title | condition | step | keyword | app | element | data | expected |
|-----|-------|-----------|------|---------|-----|---------|------|----------|
|echo_001|echo get|  | 1 | GET |  | get请求 |params={'foo1': 'bar1'} | status_code=200 |

- 其中 app 的值对应 elements 中 app 的值，如果一个测试套件中只测试一个 app，则 app 可以不填。
- 其实，只要 elements 中引用的所有关键字模块的关键字不冲突，则用例中的 app 都可以不填。
- 一般只有在同一个测试套件中要测试2个同样的关键字模块，比如要测试百度和搜狗的接口，则 elements 中后面定义的 app，在测试用例中要写 app 的值以示区分。

3. data 标签页为测试数据
4. one 标签页为唯一性测试数据

### 3. web 模块的优化

web 测试时，需要处理浏览器的标签页切换的问题
- 在 Sweetest 中，web 测试是主打功能，在框架设计上有其特殊性，比如：web 元素是绑定在 page 上的，page 再对应浏览器标签页，相对来说比较绕，不易理解；
- 在 Sweet 中，web 模块和其他模块一样，都是按需安装、使用，在 element 中元素定义也直接列在 app 下，而标签页切换则采用浏览器拟真操作：

1. `打开`操作，需在测试数据中指定当前标签页名称，如步骤1中：`#tab=百度`
2. 当`点击`操作会打开新标签页时，则下一个步骤会首先做拟真操作（框架自动切换到新标签页），如步骤6
3. 步骤6中，没有命名标签页，则`~~豆瓣~~`是个临时标签页，当切换到其他标签页时，会自动关闭未命名的`~~豆瓣~~`标签页
4. 当需要操作的标签页不是当前标签页时，请在测试数据中指定标签页名称，框架会切换过去，如步骤7
5. 要想新的标签页不关闭，则需要命名，如步骤8
6. 当`点击`产生新标签页，下一个步骤（首先做了拟真，切换到新标签页）又想回到原标签页，则需在下一个步骤的测试数据中指定标签页名称，如步骤10

| 测试步骤 | 应用 | 操作 | 元素             | 测试数据          |  备注          |
|---------|------|------|-----------------|-------------------|---------------|
| 1       |      | 打开 | http://baidu.com | `#tab=百度`       | 命名当前标签页为：`百度` |
| 2       |      | 检查 | title            | 百度一下，你就知道 | 当前标签页为：`百度` |
| 3       |      | 输入 | 搜索框            | 豆瓣             | 当前标签页为：`百度` |
| 4       |      | 点击 | 搜索按钮          |                  | 当前标签页为：`百度` |
| 5       |      | 点击 | 搜索结果#1        |                  | 当前标签页为：`百度`，点击操作后，浏览器会在新标签页打开豆瓣网站 |
| 6       |      | 检查 |  title           | 豆瓣              | 框架判断有新的标签页，首先要自动切换到新标签页，当前标签页假定为：`~~豆瓣~~`|
| 7       |      | 点击 | 搜索结果#1        | `#tab=百度`       | `百度`为已存在标签页，直接切换过去，因为上一步的`~~豆瓣~~`标签页没有命名，<br>此时会自动关闭`~~豆瓣~~`标签页，点击操作后，浏览器会在新标签页打开豆瓣网站 |
| 8       |      | 检查 |  title           | 豆瓣,`#tab=豆瓣`   |框架判断有新的标签页，会先切换到新标签页，`豆瓣`为新的命名，则命名当前标签页：`豆瓣`，<br>做了标签页命名，切换标签页不会关闭`豆瓣`标签页 |
| 9       |      | 点击 | 搜索结果#1        | `#tab=百度`       | `百度`为已存在标签页，直接切换过去（`豆瓣`标签页不会关闭），点击操作，浏览器会在新标签页打开豆瓣网站 |
| 10      |      | 点击 | 搜索结果#2        | `#tab=百度`       | 框架判断有新的标签页，会先切换到新标签页，根据指定的`百度`为已存在标签页，再切换回`百度`标签页|


## 三、Sweet 组成

架构图

![structure](../_media/sweet.svg ':size=60%')

#### 代码层：

- Autotest：或者叫 Client 模块，负责读取测试计划、解析测试计划，调用 Driver 模块循环执行测试套件，把最终的执行结果处理为测试报告
- Driver：驱动模块，是 Sweet 的核心功能（Sweet 仅此模块做了代码加密），负责调度模块，测试套件初始化，处理执行逻辑，调度关键字模块，打印/输出测试日志，返回测试结果
- KeyWords：关键字模块（如 Web, http, Mobile, DB 模块），负责模块初始化，关键字定义，测试步骤调度执行，测试结果断言
- WebServer：Web 服务，负责启动一个 Web 服务，提供测试报告访问服务

说明

- Autotest 可以通过调用 Driver 代码执行，也可以通过接口调用 Driver 执行，这意味着 Excel 用例也可以使用 Web 用例管理系统，通过接口调用 Driver 执行用例
- KeyWords 中的关键字模块可按需安装（如 `pip install sweet.web`），不使用的则无需安装，这说明关键字模块和 Driver 做了完美解耦，同时第三方开发关键字模块也相当容易（如 dubbo）,在 Sweet 中，官方和第三方关键字模块处于同等地位
- WebServer 使用了 docsify 文档网站生成器搭建，如果采用 Web 系统，亦可很容易替换



#### 资源层

- 测试计划/：由多个测试套件组成，每个测试套件是一个 Excel 文件，每个 Excel 文件包含：测试用例、元素列表、测试数据等 sheet 页
- log/： 测试执行日志文件目录
- report/：测试报告文件目录，此目录由 Web 页面动态加载

#### 用户层

- 启动执行：在命令行终端中通过 `python starat.py` 启动测试执行
- 日志打印：在命令行终端中查看执行日志
- 查看报告：在浏览器中刷新查看测试报告


## 四、用例编写

Sweet 以`测试计划`为执行单元，即每次执行都是一个`测试计划`

- 1个`测试计划`包括1至多个`测试套件`
- 1个`测试套件`包括1至多个`测试用例`
- 1个`测试用例`包括1至多个`测试步骤`

在示例项目 sweet_example 中，目录`测试计划示例`即为一个`测试计划`，“测试计划示例”是测试计划名称，我们也可以创建自己命名的目录作为测试计划；

在`测试计划示例`目录下，`baidu.xlsx`，`echo.xlsx` 即为测试套件，`baidu`，`echo`是测试套件名称；

在测试套件`baidu.xlsx`中，包括4个表格（sheet）页，分别为：测试用例、元素列表、测试数据、一次性数据，其中前2个是必须的，后2个根据需要填写；当然，我们也可以用英文名称命名，见 `echo.xlsx` 中的4个表格名称为：testcase、elements、data、one；

### 元素列表

元素列表标题如下：

| app   | element | value                                       | by   | frame | remark |
| ----- | ------- | ------------------------------------------- | ---- | ----- | ------ |
| baidu | module  | web                                         |	   |       |        |
|       | setting |	{'browserName': 'Chrome','headless': False} | json |       |        |
|       | url     |	https://www.baidu.com/	                    | url  |       |        |


app 是指一个特定的被测系统，如：百度网站，微信app，抖音app，echo接口等

- 名称自定义，需要在本列下名称唯一
- app 定义中，第一个 element 必须为：module，其 value 指定要使用的`关键字模块`（如 web,http,mobile,db等，也可以是第三方开发的关键字模块）
- app 定义中，第二个 element 一般为：setting，其 value 定义`关键字模块`的初始化参数（请根据`关键字模块`文档填写），其 by 值必须为 json 
- 后面的 element 定义自己的元素变量
- 特别说明：有一个特例：public（见`baidu.xlsx`），该 app 定义的是公共元素，无需 module 和 setting。在代码执行时，如果具体的 app 下未找到元素定义，则会在 public 中查找

### 测试用例

`baidu.xlsx`的测试用例中，主要标题如下：

| 用例编号 | 用例标题 |	前置条件 | 测试步骤	| 应用 | 操作   | 元素             | 测试数据          | 预期结果  | 输出数据  |
| ------- | -------- | ------- | ------- | ---- | ------ | ---------------- | --------------- | --------- | -------- |
|home_001 |	打开百度 |          | 1       |      | 打开	  | http://baidu.com | #tab=百度        |          |	       |
|         |	        |          | 2       |      |检查    | title            | 百度一下，你就知道 |          |          |		

- `应用`对应的是`元素列表`中的 app 列定义的值。
- 一般`应用`列无需填写
- 只有当`元素列表`中定义了2个使用相同的`关键字模块`的 app 时，后一个定义的 app 才需要在测试用例中填写`应用`的值，如示例中的`baiudu2`

亦可以用英文标题，见 `echo.xlsx` 测试用例：

| id | title | condition | step	| app | keyword | element | data | expected | output |
| -- | ----- | --------- | ---- | --- | ------- | ------- | ---- | -------- | ------ |

### 测试数据

- 测试数据是每次执行测试套件，都要运行一遍的数据
- 在测试数据中，标题为变量名，建议以下划线（_）开头，如：`_kw`，从第2行开始为测试数据。

### 一次性数据

- 一次性数据是使用过一次就不再使用的数据（如使用手机号注册，则使用过的手机号不可再次使用）
- 一次性数据最后一个标题必须是 `flag`，此列为行使用标记，不能作为变量使用
- 一次性数据每次执行读且只读取一行，并把其 `flag` 标记为 `Y`，下次就不会再使用
- 有一次性数据的 Excel，执行时请关闭文件，否则可能无法写入 `Y`


## 五、元素定位

`元素列表`的作用主要是把元素定义独立出来，一是方便维护元素信息，二是测试用例中用元素名称书写，可读性更高。

| 字段     | 注释                                                                  |
| ------- | --------------------------------------------------------------------- |
| app     | 一个特定的被测系统，如：百度网站，微信app，抖音app，echo接口等             |
| element | 元素名称，在不同的 app 下面可以同名                                 |
| by      | Selenium/Appium 定位方式，或者 json 格式， 如果是纯文本则不需要填写 by   |
| value   | 定位的值                                                   |
| frame   | 自定义字段，如 element 在 frame/iframe 中，则在此填写 frame id/name     |  
| 备注    | 注释作用                                                              |

### 定位方式

1. `id`, `link_text`, `partial_link_text`, `xpath`, `class_name`, `alert`等 Selenium 定位方式

如：

| app     | element | by   | value |
| ------- | ------- | ---- | ----- |
| 百度首页 | 搜索框  | `id` | kw    |

则自动化运行时会以 `find_element_by_id('kw')` 来定位

2. `json`方式

一般用于 setting 元素，value 需要是 Python 字典

3. 带变量的定位方式

如示例中：

| app   | element     | by    | value              |
| ----- | ----------- | ----- | ------------------ |
|       | `搜索结果#`  | xpath | `//*[@id="#"]/h3/a` |

  写用例时，需要在 `搜索结果#` 后面带上变量，如： `搜索结果#1`

| 操作  | 元素         | 测试数据   |
| ----- | ----------- | ---------- |
| 点击  | `搜索结果#1` |            |

则自动化运行时会以 `find_element_by_xpath('//*[@id="1"]/h3/a')` 来定位

已定义好的常用变量定位方式：

- id#
- link#
- \*link#
- xpath#
- class#
- name#
- div#
- input#
- button#
- table#
- url#

如：`url#www.baidu.com`

当然，如果#后面的变量不够直观的话，不建议太多使用这几个变量方式。

4. title

  页面的 title

4. current_url

  页面的 url


## 六、测试用例语法

### 用例字段

必填字段：

- 用例编号
- 测试步骤
- 操作
- 元素

### 前置条件

- `BASE`： 整个测试套件的基础，必须通过才会执行下一步，如：登录；如果有的话应该为第一个测试用例。
- `SETUP`：每个测试用例执行前需要执行的用例，只有 `SETUP` 执行成功才会执行该用例，如：返回首页。
- `MAIN`：一组用例的第一个用例，和 `SUB` 一起使用，一个 `MAIN` 后面可以带多个连续的 `SUB` 用例。此用例需要先执行 `SETUP` 用例。
- `SUB`：和 `MAIN` 一起使用，当前一个用例(`MAIN` or `SUB`)执行结果为通过时才会执行，否则测试结果置为 `Blocked`；且执行此用例前不会执行 `SETUP` 用例。
- `SKIP`: 该用例跳过 `SETUP` 执行。
- `SNIPPET`：用例片段，运行到此用例时不会立即执行，需要在其他用例中使用“执行”关键字调用此 `用例片段`，才会执行；配合 `执行` 关键字的变量赋值功能，可以实现用例复用。

注意事项：

- 每个套件中建议有 `SETUP` 步骤。当执行 `SETUP` 失败，会尝试执行一次 `BASE` -> `SETUP` 作为 `SETUP` 的执行结果。
- `BASE` 用例可以有 0 到多个，但作为 `SETUP` 中  `BASE` -> `SETUP` 的 `BASE` 只有最后一个 `BASE` 用例。
- `SETUP` 用例只能有 1 条，如果写了多条，只有最后一条起作用。

### 用例组合

用例组合：即一组测试用例。`用例编号`中如果有 # 号则该用例属于用例组合，第一个 # 号前的字符串为组合名称

| 用例编号   | 用例标题  | 前置条件   | 测试步骤 |
| --------- | --------- | --------- | ------- |
| buy#find  | 查找      |           | 1       |
|           |           |           | 2       |
| buy#order | 下单      |           | 1       |
| buy#pay   | 支付      |           | 1       |

如上3个用例同属于用例组合 `buy`，那么我们可以用如下方式循环调用

| 用例编号   | 用例标题  | 前置条件  | 测试步骤 | 应用      |  操作    | 元素    | 测试数据       |
| --------- | -------- | --------- | ------- |-----------| ------- | ------- | ------------- |
| shopping  | 网购     |           | 1       | `用例组合` | `执行`  | `buy`*2 | price=<_price>|

元素中的 `buy` 为用例组合名称

我们可以在测试数据中给变量赋值（和执行用例片段的赋值类似）

用例组合执行结果将按顺序添加在测试套件结果的结尾

> 注意：被标记为用例组合的用例默认不执行，只有通过如上的执行步骤才会执行


### 控制语句

- `if` `then` `else`

| 测试步骤  | 操作  | 元素           | 测试数据 |
| -------- | ----- | -------------- | ------- |
| `^3`     | 检查  | 页面标题        | \*知乎  |
| `>4`     | 点击  | link#登录       |        |
| `<5`     | 点击  | link#注册机构号 |         |

`^` 表示 `if` 语句

`>` 表示 `then` 语句

`<` 表示 `else` 语句

`if`(`^`) 语句成功时，执行 `then`(`>`) 语句，失败时执行 `else`(`<`) 语句。无论后面有没有 `then` 或者 `else` 语句，不影响后续步骤执行。

`then` 语句或者 `else` 语句，当不被执行时，测试结果为 `-`，不影响测试用例结果和后续步骤执行。当执行时，和正常步骤一样，成功则继续，失败则该用例失败。

在`if`(`^`) 语句后，`then`(`>`) 或 `else`(`<`) 可以出现 0 次或多次，框架按步骤顺序进行判断执行。


## 七、关键字模块开发

关键字模块是指对单一被测系统的操作集合。如 http 接口测试，其中 http 是模块，GET, POST 是关键字。

关键字模块按照代码规模和复杂度可以采用 python 模块（单文件）或包（目录及多个文件）形式进行开发，请参考 sweet\modules 下面的 http.py 模块或 web 包。

下面以示例模块 publish.py 举例：

```python
keywords = {                            # 定义关键字
    '诗歌': 'POETRY',                   # key 为关键字，英文须大写，value 是对应的函数名  
    'POETRY': 'POETRY'                  # 关键字建议中、英文各定义一份
}

class App:                              # 约定 

    keywords = keywords                 # 约定

    def __init__(self, setting):        # 约定，setting 是 element 中定义的字典

        self.header = setting['header'] # 示例，根据需要提取 setting 参数
        self.footer = setting['footer']

    def _close(self):                   # 约定，自动化退出时，执行的清理函数

        pass                            # 根据需要编写，请参考 web 实现

    def _call(self, step):              # 约定，step 为用例步骤

        # 根据关键字调用关键字实现
        getattr(self, step['keyword'].lower())(step)  # 约定，调用关键字函数

    def poetry(self, step):             # 需自己实现的关键字函数
        ...
```
注：
1. 约定的代码行，照写即可
2. 日志和运行时变量，请参考 http.py 中的 log 和 vars 的使用
3. 包形式请参考 web 包


## 八、Sweet 问答

1. Sweet 与其他自动化测试框架最大的不同是什么？

答：Sweet 是让**业务测试人员**自己写自动化测试用例

2. 其他自动化测试框架是谁写测试用例呢？

答：大部分都是专门的自动化测试人员写**用例脚本**

3. 为什么他们不让业务测试人员写呢？

答：用例脚本也是**代码**，有一定的门槛，而大部分业务测试不会代码

4. 那 Sweet 的业务测试就会代码了吗？

答：不是，Sweet 的测试用例不是用例脚本，而是在表格中用**文本**编写的

5. 所以写 Sweet 的测试用例不需要会代码？

答：是的，Sweet 的测试用例和功能测试用例**类似**，业务测试可以轻松上手

6. 业务人员写自动化用例有什么优劣吗？

答：业务人员自己写自动化测试用例，减少了**沟通成本**，没有中间商赚差价

7. 脚本用例就没有优势吗？

答：业界有句话：是代码就有 bug，脚本用例也是代码，且人员代码能力更低，也就更加**不可靠**

8. Sweet 本身不也是代码写的吗？

答：Sweet 是按照产品极软件打造的，核心代码不足千行，经过4年的不断优化和改进，**稳定性**已经千锤百炼

9. 如果使用 Sweet，是不是可以不需要自动化测试人员了？

答：Sweet 的测试用例是业务测试人员编写，但是还是需要一个 Sweet **教练**

10. 听起来，人员并没有减少？

答：假如要支持20个业务测试，Sweet 可以**只要**1个教练，而其他框架可能需要5个自动化测试人员

11. 开发需求经常变更，自动化测试维护成本很大， Sweet 有解决办法吗？

答：Sweet 采用了定位、用例、测试数据**分层设计**，以及变量替换等方法，维护的工作量是最小的

12. 都说自动化测试只能覆盖核心功能，特别是 UI 测试，Sweet 也是这样吗？

答：那是因为他们的用例设计和维护成本太高，Sweet 建议覆盖 **80%** 的业务用例

13. 业务测试每天都忙于点点点，哪有这么多时间编写自动化用例？

答：这需要一点**气魄**，先在试点项目达到自动化 80% 覆盖，再看看他们还要不要这么忙

14. 新的业务很多呀，自动化测试也帮不上忙？

答：非也，首先新业务上可以做接口测试，如果 API 文档写的规范，甚至可以提前写好接口用例；其次，手工测试可以只做一遍，之后就是自动化用例**边测边写**

15. 按这个方法，测试周期是长了还是短了？

答：如果严格按照这个模式来，测试周期一定是短的，我希望测试人员一边**喝茶**，一般看 Sweet 打印日志

16. 所有的项目都适用这个模式吗？

答：也不是，大部分开发模式，无论是瀑布模型还是 V 字模型，亦或是敏捷开发，都可以**适用**；但是如果是那种质量要求不高，开发极为迅速，测试周期按小时计算的小需求，则无法适用。

17. Sweet 还有其他优势吗？

答：Sweet 的 Web 测试报告，基于 Markdown 文件，无需安装数据库，既简单又**漂亮**

18. Sweet 可以集成到 DevOps 吗？

答：当然，Sweet 既可以命令行方式启动，也可以接口调用，很容易**集成**到 DevOps 系统

19. 如果有些功能 Sweet 不支持咋办？

答： Sweet 可以满足 99% 的测试需求，同时也支持**自定义函数**和**关键字模块**二次开发

20. 那么，最后请用一句话送给广大自动化测试的同学吧？

答：Sweet 本来就**在你心里**，只不过偶然被我敲了出来


## 小试牛刀

[小试牛刀](/sweet/start.md)

## 简洁是美

[简洁是美](/sweet/simple.md)